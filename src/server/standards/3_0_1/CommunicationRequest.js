const DomainResource = require('./DomainResource');
const Identifier = require('./Identifier');
const Reference = require('./Reference');
const CodeableConcept = require('./CodeableConcept');
const CommunicationRequest_Payload = require('./CommunicationRequest_Payload');
const Period = require('./Period');
const CommunicationRequest_Requester = require('./CommunicationRequest_Requester');
const Annotation = require('./Annotation');

class CommunicationRequest extends DomainResource {

	constructor ( opts ) {
		super( opts );
		this._resourceType = 'CommunicationRequest';
		Object.assign(this, opts);
	}

	static get __resourceType () {
		return 'CommunicationRequest';
	}

	// This is a CommunicationRequest resource
	get resourceType () {
		return this._resourceType;
	}

	set resourceType ( new_value ) {
		// Throw if new value is not in the allowed values
		let allowed_values = ['CommunicationRequest'];
		if ( new_value && allowed_values.indexOf(new_value) === -1 ) {
			throw new Error(`Expected one of ${allowed_values}, got ${new_value} for field resourceType`);
		}
		this._resourceType = new_value;
	}

	// A unique ID of this request for reference purposes. It must be provided if user wants it returned as part of any output, otherwise it will be autogenerated, if needed, by CDS system. Does not need to be the actual ID of the source system.
	get identifier () {
		return this._identifier;
	}

	set identifier ( new_value ) {
		this._identifier = Array.isArray(new_value) ? new_value.map(val => new Identifier(val)) : [new Identifier(new_value)];
	}

	// A plan or proposal that is fulfilled in whole or in part by this request.
	get basedOn () {
		return this._basedOn;
	}

	set basedOn ( new_value ) {
		this._basedOn = Array.isArray(new_value) ? new_value.map(val => new Reference(val)) : [new Reference(new_value)];
	}

	// Completed or terminated request(s) whose function is taken by this new request.
	get replaces () {
		return this._replaces;
	}

	set replaces ( new_value ) {
		this._replaces = Array.isArray(new_value) ? new_value.map(val => new Reference(val)) : [new Reference(new_value)];
	}

	// A shared identifier common to all requests that were authorized more or less simultaneously by a single author, representing the identifier of the requisition, prescription or similar form.
	get groupIdentifier () {
		return this._groupIdentifier;
	}

	set groupIdentifier ( new_value ) {
		this._groupIdentifier = new Identifier(new_value);
	}

	// The status of the proposal or order.
	get status () {
		return this._status;
	}

	set status ( new_value ) {
		// Throw if new value does not match the pattern
		let pattern = /[^\s]+([\s]?[^\s]+)*/;
		if ( new_value && !pattern.test(new_value) ) {
			throw new Error(`Invalid format for ${new_value} on field status`);
		}
		this._status = new_value;
	}

	// The type of message to be sent such as alert, notification, reminder, instruction, etc.
	get category () {
		return this._category;
	}

	set category ( new_value ) {
		this._category = Array.isArray(new_value) ? new_value.map(val => new CodeableConcept(val)) : [new CodeableConcept(new_value)];
	}

	// Characterizes how quickly the proposed act must be initiated. Includes concepts such as stat, urgent, routine.
	get priority () {
		return this._priority;
	}

	set priority ( new_value ) {
		// Throw if new value does not match the pattern
		let pattern = /[^\s]+([\s]?[^\s]+)*/;
		if ( new_value && !pattern.test(new_value) ) {
			throw new Error(`Invalid format for ${new_value} on field priority`);
		}
		this._priority = new_value;
	}

	// A channel that was used for this communication (e.g. email, fax).
	get medium () {
		return this._medium;
	}

	set medium ( new_value ) {
		this._medium = Array.isArray(new_value) ? new_value.map(val => new CodeableConcept(val)) : [new CodeableConcept(new_value)];
	}

	// The patient or group that is the focus of this communication request.
	get subject () {
		return this._subject;
	}

	set subject ( new_value ) {
		this._subject = new Reference(new_value);
	}

	// The entity (e.g. person, organization, clinical information system, device, group, or care team) which is the intended target of the communication.
	get recipient () {
		return this._recipient;
	}

	set recipient ( new_value ) {
		this._recipient = Array.isArray(new_value) ? new_value.map(val => new Reference(val)) : [new Reference(new_value)];
	}

	// The resources which were related to producing this communication request.
	get topic () {
		return this._topic;
	}

	set topic ( new_value ) {
		this._topic = Array.isArray(new_value) ? new_value.map(val => new Reference(val)) : [new Reference(new_value)];
	}

	// The encounter or episode of care within which the communication request was created.
	get context () {
		return this._context;
	}

	set context ( new_value ) {
		this._context = new Reference(new_value);
	}

	// Text, attachment(s), or resource(s) to be communicated to the recipient.
	get payload () {
		return this._payload;
	}

	set payload ( new_value ) {
		this._payload = Array.isArray(new_value) ? new_value.map(val => new CommunicationRequest_Payload(val)) : [new CommunicationRequest_Payload(new_value)];
	}

	// The time when this communication is to occur.
	get occurrenceDateTime () {
		return this._occurrenceDateTime;
	}

	set occurrenceDateTime ( new_value ) {
		// Throw if new value does not match the pattern
		let pattern = /-?[0-9]{4}(-(0[1-9]|1[0-2])(-(0[0-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?/;
		if ( new_value && !pattern.test(new_value) ) {
			throw new Error(`Invalid format for ${new_value} on field occurrenceDateTime`);
		}
		this._occurrenceDateTime = new_value;
	}

	// The time when this communication is to occur.
	get occurrencePeriod () {
		return this._occurrencePeriod;
	}

	set occurrencePeriod ( new_value ) {
		this._occurrencePeriod = new Period(new_value);
	}

	// For draft requests, indicates the date of initial creation.  For requests with other statuses, indicates the date of activation.
	get authoredOn () {
		return this._authoredOn;
	}

	set authoredOn ( new_value ) {
		// Throw if new value does not match the pattern
		let pattern = /-?[0-9]{4}(-(0[1-9]|1[0-2])(-(0[0-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?/;
		if ( new_value && !pattern.test(new_value) ) {
			throw new Error(`Invalid format for ${new_value} on field authoredOn`);
		}
		this._authoredOn = new_value;
	}

	// The entity (e.g. person, organization, clinical information system, or device) which is to be the source of the communication.
	get sender () {
		return this._sender;
	}

	set sender ( new_value ) {
		this._sender = new Reference(new_value);
	}

	// The individual who initiated the request and has responsibility for its activation.
	get requester () {
		return this._requester;
	}

	set requester ( new_value ) {
		this._requester = new CommunicationRequest_Requester(new_value);
	}

	// Describes why the request is being made in coded or textual form.
	get reasonCode () {
		return this._reasonCode;
	}

	set reasonCode ( new_value ) {
		this._reasonCode = Array.isArray(new_value) ? new_value.map(val => new CodeableConcept(val)) : [new CodeableConcept(new_value)];
	}

	// Indicates another resource whose existence justifies this request.
	get reasonReference () {
		return this._reasonReference;
	}

	set reasonReference ( new_value ) {
		this._reasonReference = Array.isArray(new_value) ? new_value.map(val => new Reference(val)) : [new Reference(new_value)];
	}

	// Comments made about the request by the requester, sender, recipient, subject or other participants.
	get note () {
		return this._note;
	}

	set note ( new_value ) {
		this._note = Array.isArray(new_value) ? new_value.map(val => new Annotation(val)) : [new Annotation(new_value)];
	}

	toJSON () {
		return Object.assign(super.toJSON(), {
			resourceType: this._resourceType,
			identifier: this._identifier && this._identifier.map(v => v.toJSON()),
			basedOn: this._basedOn && this._basedOn.map(v => v.toJSON()),
			replaces: this._replaces && this._replaces.map(v => v.toJSON()),
			groupIdentifier: this._groupIdentifier && this._groupIdentifier.toJSON(),
			status: this._status,
			category: this._category && this._category.map(v => v.toJSON()),
			priority: this._priority,
			medium: this._medium && this._medium.map(v => v.toJSON()),
			subject: this._subject && this._subject.toJSON(),
			recipient: this._recipient && this._recipient.map(v => v.toJSON()),
			topic: this._topic && this._topic.map(v => v.toJSON()),
			context: this._context && this._context.toJSON(),
			payload: this._payload && this._payload.map(v => v.toJSON()),
			occurrenceDateTime: this._occurrenceDateTime,
			occurrencePeriod: this._occurrencePeriod && this._occurrencePeriod.toJSON(),
			authoredOn: this._authoredOn,
			sender: this._sender && this._sender.toJSON(),
			requester: this._requester && this._requester.toJSON(),
			reasonCode: this._reasonCode && this._reasonCode.map(v => v.toJSON()),
			reasonReference: this._reasonReference && this._reasonReference.map(v => v.toJSON()),
			note: this._note && this._note.map(v => v.toJSON())
		});
	}

}

module.exports = CommunicationRequest;
